#!/usr/bin/env bash

if [[ ${BASH_VERSION%%.*} -lt 4 ]]
then
	echo "Bash ^4.x required." >&2
	exit 1
fi

status=(
	[200]="OK"
	[400]="Bad Request"
	[403]="Forbidden"
	[404]="Not Found"
)

function render {
	local format=$(cat << EOF
<html>
<head><title>%s</title></head>
<body><h1><center>%d %s</center></h1><hr><center>shttpd</center></body>
</html>
EOF
)
	local body=$(printf "$format" "${status[$1]}" $1 "${status[$1]}")
	printf "HTTP/1.1 %d %s\r\n" $1 "${status[$1]}"
	printf "Content-Type: text/html\r\n"
	printf "Content-Length: %d\r\n\r\n" ${#body}
	echo -n "$body"
}

temp=$(mktemp)
trap "rm -f $temp" EXIT

phase=1
method=
request_uri=
declare -A header

while :
do
	# Phase 1: Request Line
	if [[ $phase -eq 1 ]]
	then
		read request_line
		method=${request_line%% *}
		request_uri="$PWD${request_line#* }"
		request_uri="${request_uri%% *}"
		((phase++))
	# Phase 2: Request Headers
	elif [[ $phase -eq 2 ]]
	then
		read line
		if [[ $line = $(printf "\r") ]]
		then
			((phase++))
		else
			head=${line%%\r\n}
			key="${head%%: *}"
			val="${head#*: }"
			header[$key]="$val"
		fi
	# Phase 3: Request Body
	elif [[ $phase -eq 3 ]]
	then
		if ! [[ -z ${header[Content-Length]} ]]
		then
			read -rd' ' -n${header[Content-Length]} body
		fi
		((phase++))
	# Phase 4: Response
	elif [[ $phase -eq 4 ]]
	then
		# avoid path traversal
		if ! [[ "$(realpath "$request_uri")" =~ ^$PWD ]]
		then
			render 403
		# $request_uri is not a regular file
		elif ! [[ -f "$request_uri" ]]
		then
			render 404
		# $request_uri is not readable
		elif ! [[ -r "$request_uri" ]]
		then
			render 403
		# OK: cgi
		elif [[ ${request_uri##*.} = "cgi" ]]
		then
			if [[ -x "$request_uri" ]]
			then
				echo 'HTTP/1.1 200 OK'
				"$request_uri"
			else
				render 403
			fi
		# OK: static content
		else
			# set mime type
			if [[ ${request_uri##*.} = "html" ]]
			then
				mime='text/html'
			elif [[ ${request_uri##*.} = "css" ]]
			then
				mime='text/css'
			elif [[ ${request_uri##*.} = "js" ]]
			then
				mime='text/javascript'
			elif [[ ${request_uri##*.} = "txt" ]]
			then
				mime='text/plain'
			elif [[ ${request_uri##*.} = "png" ]]
			then
				mime='image/png'
			elif [[ ${request_uri##*.} = "jpg" ]] || [[ ${request_uri##*.} = "jpeg" ]]
			then
				mime='image/jpeg'
			else
				mime='application/octet-stream'
			fi
			# send response
			echo 'HTTP/1.1 200 OK'
			echo "Content-Type: $mime"
			# Check Accept-Encoding in order
			while ! [[ -z "${header[Accept-Encoding]}" ]]
			do
				if [[ "${header[Accept-Encoding]%%, *}" = gzip ]] && which gzip &>/dev/null
				then
					cat $request_uri | gzip --best > $temp
					stat=($(ls -l $temp))
					echo "Content-Length: ${stat[4]}"
					echo "Content-Encoding: gzip"
					echo
					cat $temp
					break
				elif [[ "${header[Accept-Encoding]%%, *}" = deflate ]] && which pigz &>/dev/null
				then
					pigz -cz --best $request_uri > $temp
					stat=($(ls -l $temp))
					echo "Content-Length: ${stat[4]}"
					echo "Content-Encoding: deflate"
					echo
					cat $temp
					break
				fi
				header[Accept-Encoding]="${header[Accept-Encoding]#*, }"
			done
			# not compressed (= "Accept-Encoding: identity")
			if [[ -z "${header[Accept-Encoding]}" ]]
			then
				stat=($(ls -l $request_uri))
				echo "Content-Length: ${stat[4]}"
				echo
				cat $request_uri
			fi
		fi
		exit
	fi
done
