#!/usr/bin/env bash

if [[ ${BASH_VERSION%%.*} -lt 4 ]]
then
	echo "Bash ^4.x required." >&2
	exit 1
fi

http_status=(
	[200]="OK"
	[400]="Bad Request"
	[403]="Forbidden"
	[404]="Not Found"
	[501]="Not Implemented"
)

valid_methods=(
	"GET"
	"POST"
	"HEAD"
)

html_format=$(cat << EOF
<html>
<head><title>%s</title></head>
<body><h1><center>%d %s</center></h1><hr><center>shttpd</center></body>
</html>
EOF
)

function render {
	local body=$(printf "$html_format" "${http_status[$1]}" $1 "${http_status[$1]}")
	printf "HTTP/1.1 %d %s\r\n" $1 "${http_status[$1]}"
	printf "Content-Type: text/html\r\n"
	printf "Content-Length: %d\r\n\r\n" ${#body}
	echo -n "$body"
}

function in_array {
	local -n haystack=$1
	local needle=$2
	for val in "${haystack[@]}"
	do
		if [[ $val = $needle ]]
		then
			return 0
		fi
	done
	return 1
}

function mime_from_ext {
	local mime
	case ${request_uri##*.} in
		html)
			mime='text/html';;
		css)
			mime='text/css';;
		js)
			mime='text/javascript';;
		txt)
			mime='text/plain';;
		png)
			mime='image/png';;
		jpg|jpeg)
			mime='image/jpeg';;
		*)
			mime='application/octet-stream';;
	esac
	printf "%s" $mime
}

temp=$(mktemp)
trap "rm -f $temp" EXIT

phase=1
method=
request_uri=
declare -A header

while :
do
	# Phase 1: Request Line
	if [[ $phase -eq 1 ]]
	then
		read request_line
		method=${request_line%% *}
		request_uri="$PWD${request_line#* }"
		request_uri="${request_uri%% *}"
		# given method is not valid
		if ! in_array valid_methods $method
		then
			render 501
			exit
		fi
		((phase++))
	# Phase 2: Request Headers
	elif [[ $phase -eq 2 ]]
	then
		read line
		if [[ $line = $(printf "\r") ]]
		then
			((phase++))
		else
			head=${line%%\r\n}
			key="${head%%: *}"
			val="${head#*: }"
			header[$key]="$val"
		fi
	# Phase 3: Request Body
	elif [[ $phase -eq 3 ]]
	then
		if ! [[ -z ${header[Content-Length]} ]]
		then
			read -rd' ' -n${header[Content-Length]} body
		fi
		((phase++))
	# Phase 4: Response
	elif [[ $phase -eq 4 ]]
	then
		# avoid path traversal
		if ! [[ "$(realpath "$request_uri")" =~ ^$PWD ]]
		then
			render 403
		# $request_uri is not a regular file
		elif ! [[ -f "$request_uri" ]]
		then
			render 404
		# $request_uri is not readable
		elif ! [[ -r "$request_uri" ]]
		then
			render 403
		# OK: cgi
		elif [[ ${request_uri##*.} = "cgi" ]]
		then
			if [[ -x "$request_uri" ]]
			then
				echo 'HTTP/1.1 200 OK'
				"$request_uri"
			else
				render 403
			fi
		# OK: static content
		else
			# send response
			echo 'HTTP/1.1 200 OK'
			echo "Content-Type: $(mime_from_ext ${request_uri##*.})"
			# Check Accept-Encoding in order
			while ! [[ -z "${header[Accept-Encoding]}" ]]
			do
				if [[ "${header[Accept-Encoding]%%, *}" = gzip ]] && which gzip &>/dev/null
				then
					cat $request_uri | gzip --best > $temp
					stat=($(ls -l $temp))
					echo "Content-Length: ${stat[4]}"
					echo "Content-Encoding: gzip"
					echo
					cat $temp
					break
				elif [[ "${header[Accept-Encoding]%%, *}" = deflate ]] && which pigz &>/dev/null
				then
					pigz -cz --best $request_uri > $temp
					stat=($(ls -l $temp))
					echo "Content-Length: ${stat[4]}"
					echo "Content-Encoding: deflate"
					echo
					cat $temp
					break
				fi
				header[Accept-Encoding]="${header[Accept-Encoding]#*, }"
			done
			# not compressed (= "Accept-Encoding: identity")
			if [[ -z "${header[Accept-Encoding]}" ]]
			then
				stat=($(ls -l $request_uri))
				echo "Content-Length: ${stat[4]}"
				echo
				cat $request_uri
			fi
		fi
		exit
	fi
done
